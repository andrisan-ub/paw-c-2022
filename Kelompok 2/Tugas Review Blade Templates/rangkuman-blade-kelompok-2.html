<html>
    <head></head>
    <body>
        
        <h1>Rangkuman Blade Template Laravel</h1>

        <!-- Danish -->


        <!-- Candra -->
    <h3>The Loop Variable</h3>
    <p>
      Saat melakukan iterasi melalui loop foreach, variabel $loop akan tersedia di dalam loop Anda. Variabel ini menyediakan akses ke beberapa bit informasi yang berguna seperti indeks loop saat ini dan apakah ini adalah iterasi pertama atau terakhir melalui loop:
    </p>
    
    <p><code>@foreach ($users as $user)</code></p>
    <p><code>@if ($loop->first)</code></p>
        <p><code>This is the first iteration.</code></p>
    <p><code>@endif</code></p>
 
    <p><code>@if ($loop->last)</code></p>
        <p><code>This is the last iteration.</code></p>
    <p><code>@endif</code></p>
 
    <p>This is user {{ $user->id }}</code></p>
<p><code>@endforeach</code></p>
    <p>Jika Anda berada dalam loop bersarang, Anda dapat mengakses variabel $loop loop induk melalui properti induk:</p>
<p><code>@foreach ($users as $user)</p></code>
    <p><code>@foreach ($user->posts as $post)</p></code>
        <p><code>@if ($loop->parent->first)</p></code>
            <p><code>This is the first iteration of the parent loop.</p></code>
        <p><code>@endif</p></code>
    <p><code>@endforeach</p></code>
<p><code>@endforeach</p></code>
    <br />
    <!-- Conditional Classes -->
    <h3>Conditional Classes</h3>
    <p>Arahan @class mengkompilasi string kelas CSS secara kondisional. Arahan menerima array kelas di mana kunci array berisi kelas atau kelas yang ingin Anda tambahkan, sedangkan nilainya adalah ekspresi boolean. Jika elemen array memiliki kunci numerik, elemen tersebut akan selalu disertakan dalam daftar kelas yang dirender:</p>
 <p><code>@php</p></code>
  <p><code>$isActive = false;</p></code>
    <p><code>$hasError = true;</p></code>
<p><code>@endphp</p></code>
 
<p><code><span @class([</p></code>
    <p><code>'p-4',</p></code>
    <p><code>'font-bold' => $isActive,</p></code>
    <p><code>'text-gray-500' => ! $isActive,</p></code>
    <p><code>'bg-red' => $hasError,</p></code>
<p><code>])></span></p></code>

<h3>Including Subviews</h3>
<p>Direktif @include Blade memungkinkan Anda menyertakan tampilan Blade dari dalam tampilan lain. Semua variabel yang tersedia untuk tampilan induk akan tersedia untuk tampilan yang disertakan:</p>
<p><code><div></p></code>
    <p><code>@include('shared.errors')</p></code>
 
    <p><code><form></p></code>
       <p><code> <!-- Form Contents --></p></code>
    <p><code></form></p></code>
<p><code></div></p></code>
<p>Meskipun tampilan yang disertakan akan mewarisi semua data yang tersedia di tampilan induk, Anda juga dapat meneruskan larik data tambahan yang harus tersedia untuk tampilan yang disertakan:</p>
<p><code>@include('view.name', ['status' => 'complete'])</p></code>

<p>Jika Anda mencoba include tampilan yang tidak ada, Laravel akan membuat kesalahan. Jika Anda ingin menyertakan tampilan yang mungkin ada atau tidak, Anda harus menggunakan direktif @includeIf:</p>
<p><code>@includeIf('view.name', ['status' => 'complete'])</p></code>

<p>Jika Anda ingin @include tampilan jika ekspresi boolean yang diberikan bernilai benar atau salah, Anda dapat menggunakan arahan @includeWhen dan 
@includeUnless:</p>

<p><code>@includeWhen($boolean, 'view.name', ['status' => 'complete'])</p></code>
 
<p><code>@includeUnless($boolean, 'view.name', ['status' => 'complete'])</p></code>

<p>Untuk menyertakan tampilan pertama yang ada dari larik tampilan tertentu, Anda dapat menggunakan direktif includeFirst:pression mengevaluasi ke true atau false, Anda dapat menggunakan arahan @includeWhen dan @includeUnless:</p>

<p><code>@includeFirst(['custom.admin', 'admin'], ['status' => 'complete'])</p></code>


<!-- Additional Attribut-->
    <h3>Conditional Classes</h3>
<p>Untuk kenyamanan, Anda dapat menggunakan @checked directive untuk dengan mudah menunjukkan jika input kotak centang HTML yang diberikan "dicentang". Arahan ini akan diperiksa kembali jika kondisi yang diberikan bernilai benar:</p>
<p><code><input type="checkbox"</p></code>
       <p><code> name="active"</p></code>
        <p><code>value="active"</p></code>
        <p><code>@checked(old('active', $user->active)) /></p></code>
<p>demikian pula, arahan @selected dapat digunakan untuk menunjukkan apakah opsi pilih yang diberikan harus "dipilih":</p>
<p><code><select name="version"></p></code>
    <p><code>@foreach ($product->versions as $version)</p></code>
        <p><code><option value="{{ $version }}" @selected(old('version') == $version)></p></code>
            <p><code>{{ $version }}</p></code>
        <p><code></option></p></code>
    <p><code>@endforeach</p></code>
<p><code></select></p></code>
<p>Selain itu, arahan @disabled dapat digunakan untuk menunjukkan apakah elemen tertentu harus "dinonaktifkan":</p>
	<p><code><button type="submit" @disabled($errors->isNotEmpty())>Submit</button></p></code>
<p>Selain itu, direktif @readonly dapat digunakan untuk menunjukkan apakah elemen yang diberikan harus "readonly":</p>
<p><code><input type="email"/<p></code>
        <p><code>name="email"</p></code>
        <p><code>value="email@laravel.com"</p></code>
        <p><code>@readonly($user->isNotAdmin()) /></p></code>
<p>Selain itu, arahan @required dapat digunakan untuk menunjukkan apakah elemen tertentu harus "diperlukan":</p>
<p><code><input type="text"</p></code>
        <p><code>name="title"</p></code>
        <p><code>value="title"</p></code>
        <p><code>@required($user->isAdmin()) /></p></code>


        <!-- Hanif -->
        <h4>Comment</h4>
        <p>Blade menyediakan <em>comment</em> untuk view namun <em>comment</em>
        tidak di-<em>include</em> ke HTML yang di-<em>return</em>. </p>

        <h3>Components</h3>
        <p>Components memiliki manfaat yang mirip dengan <em>sections, 
        Layouts,</em> dan <em>Includes</em> sehingga dapat digunakan untuk
        membangun sistem yang dapa diandalkan dan <em>extensible</em>.</p>

        <p>Ada dua pendekatan untuk menulis <em>component</em>:</p>
        <ul>
            <li><em>Class based components</em></li>
            <li><em>Anonymous components</em></li>
        </ul>
        
        <p>Untuk membuat <em>component</em> berbasis kelas, Anda dapat menggunakan perintah Artisan <code>make:component</code>.</p>
        <p>Contoh:</p>
        <p><code>php artisan make:component Alert</code></p>
        
        <p>Perintah <code>make:component</code> juga akan membuat template <em>view</em> untuk <em>component</em>. <em>View</em> akan ditempatkan di direktori <code>resources/views/components</code>. 
        Saat menulis <em>component</em> untuk aplikasi Anda sendiri, <em>component</em> secara otomatis ditemukan dalam direktori <code>app/View/Components</code> dan direktori 
        <code>resources/views/components</code>, jadi biasanya tidak diperlukan registrasi <em>component</em> lebih lanjut.</p>
        
        <p>Jika ingin membuat <em>component</em> anonim (<em>component</em> dengan hanya template Blade dan tanpa kelas), bisa menggunakan flag <code>--view</code> saat menjalankan perintah <code>make:component</code>.</p> 
        <p>Contoh:</p>
            <p><code>php artisan make:component forms.input --view</code></p>   

        <p><strong>Mendaftarkan <em>Package Component</em> Secara Manual</strong></p>

        <p>Saat menulis <em>component</em> untuk aplikasi Anda sendiri, <em>component</em> secara otomatis ditemukan dalam direktori <code>app/View/Components</code> dan direktori <code>resources/views/components</code>.
            Namun, jika Anda membuat <em>package</em> yang menggunakan <em>component</em> Blade, Anda perlu mendaftarkan kelas <em>component</em> dan alias tag HTML-nya secara manual.</p>
        <p>Contoh:</p>
            <p><code>
                use Illuminate\Support\Facades\Blade;<br>
                <br>
                /**<br>
                * Bootstrap your package's services.<br>
                */<br>
                <br>
                public function boot()<br>
                {<br>
                &emsp;&emsp;Blade::component('package-alert', Alert::class);<br>
                }<br>
            </code></p>

        <p>Setelah <em>component</em> terdaftar, <em>component</em> tersebut dapat dirender menggunakan alias tagnya</p>
        <p>Contoh:</p>
        <p><code>&lt;x-package-alert/&gt;</code></p>

        <h4>Render Components</h4>

        <p>Untuk me-<em>render component</em>, dapat menggunakan tag <em>component</em> Blade dalam salah satu template Blade Anda. Tag <em>component</em> blade dimulai dengan string <code>x-</code> diikuti dengan 
            nama <em>kebab-case</em> dari kelas <em>component</em>.</p>
        <p>Contoh:</p>
        <p><code>
            &lt;x-alert/&gt;<br>
            <br>
            &lt;x-user-profile&gt;
        </code></p>
    
        <h4>Pass Data ke <em>Components</em></h4>

        <p>Data di-<em>pass</em> ke <em>component</em> Blade menggunakan atribut HTML. Nilai primitif yang <em>hard-code</em> dapat diteruskan ke <em>component</em> menggunakan string atribut HTML sederhana. 
            <em>Expression</em> dan <em>variable</em> PHP harus diteruskan ke <em>component</em> melalui atribut yang menggunakan karakter <code>:</code> sebagai awalan.</p>
        <p>Contoh:</p>
        <p><code>&lt;x-alert type="error" :message="$message"/&gt;</code></p>
        <p>Semua atribut data <em>component</em> harus didefinisikan di dalam konstruktor kelasnya.</p>
        
        <p>Fitur: </p>
        <ul>
            <li><em>Casing</em></li>
            <li>Sintaks Atribut Pendek</li>
            <li><em>Escape</em> Ketika <em>Render</em> Atribut</li>
            <li>Metode dalam <em>Components</em></li>
            <li>Mengakses Atribut dan <em>Slot</em> dalam <em>Components</em></li>
            <li>Dependensi Tambahan</li>
            <li>Menyembunyikan Atribut atau Metode dari <em>Components</em></li>
        </ul>

        <h4>Atribut <em>Components</em></h4>
        <p>Atribut <em>component</em> adalah <em>typed fields</em> yang ditetapkan pada instance dari suatu <em>component</em>, dan dapat direferensikan dari dalam markup <em>component</em> menggunakan sintaks <em>expression</em>. 
            Atribut memungkinkan untuk membuat <em>component</em> lebih dinamis.</p>
        <p>Contoh:</p>
        <p><code>&lt;x-alert type="error" :message="$message" class="mt-4"/&gt;</code></p>
        
        <p>Render atribut dalam <em>view</em>:</p>
        <p><code>
            &lt;div {{ $attributes }}&gt;<br>
            &emsp;&emsp;Component content <br>
            &lt;/div&gt;<br>
        </code></p>

        <p>Ketentuan: </p>
        <ul>
            <li>Atribut <em>Default/Merged</em></li>
            <p>Contoh:</p>
            <p><code>
                &lt;div {{ $attributes->merge(['class' => 'alert alert-'.$type]) }}&gt;<br>
                &emsp;&emsp;{{ $message }} <br>
                &lt;/div&gt; <br>
            </code></p>
            <li>Penggabungan Kondisional Kelas</li>
            <p>Contoh:</p>
            <p><code>
                &lt;button {{ $attributes->class(['p-4'])->merge(['type' => 'button']) }}&gt; <br>
                &emsp;&emsp;{{ $slot }} <br>
                &lt;/button&gt; <br>
            </code></p>
                
            <li>Penggabungan Atribut Non-Kelas</li>
            <p>Contoh:</p>
            <p><code>
                &lt;button {{ $attributes->merge(['type' => 'button']) }}&gt; <br>
                &emsp;&emsp;{{ $slot }} <br>
                &lt;/button&gt; <br>
            </code></p>
            
            <li>Pengambilan dan Filter Atribut</li>
            <p>Contoh:</p>
            <p><code>
                {{ $attributes->get('class') }} <br>
                <br>
                {{ $attributes->filter(fn ($value, $key) => $key == 'foo') }} 
            </code></p>
        </ul>

        <h4>Reserved Keyword</h4>
        <p>Secara default, beberapa kata kunci disimpan untuk penggunaan internal Blade untuk merender komponen. 
            Kata kunci berikut tidak dapat didefinisikan sebagai properti publik atau nama metode dalam komponen:</p>
        <ul>
            <li>data</li>
            <li>render</li>
            <li>resolveView</li>
            <li>shouldRender</li>
            <li>view</li>
            <li>withAttributes</li>
            <li>withName</li>
        </ul>

        <h4><em>Slots</em></h4>

        <p>Seringkali, kita harus meneruskan konten tambahan ke komponen Anda melalui "slot". Slot komponen dirender 
            dengan <code>echo</code> variabel <code>$slot</code>.</p>
        
        <p>Contoh:</p>
        <p><code>
            &lt;div class="alert alert-danger"&gt; <br>
            &emsp;&emsp;{{ $slot }} <br>
            &lt;/div&gt; <br>
        </code></p>

        <p><strong>Scoped Slots</strong></p>
        <p>Scoped Slots digunakan untuk mengakses data atau metode dari komponen dengan "scoped slots".</p>
        <p>Contoh:</p>
        <p><code>
            &lt;x-alert&gt;<br>
            &emsp;&emsp;&lt;x-slot:title&gt;<br>
                &emsp;&emsp;&emsp;&emsp;{{ $component->formatAlert('Server Error') }} <br>
            &emsp;&emsp;&lt;/x-slot&gt; <br>
            
            &emsp;&emsp;&lt;strong&gt;Whoops!&lt;/strong&gt; Something went wrong! <br>
            &lt;/x-alert&gt; <br>
        </code></p>

        <p><strong>Atribut Slot</strong></p>
        <p>Contoh:</p>
        <p><code>
            &lt;x-card class="shadow-sm"&gt; <br>
                &emsp;&emsp;&lt;x-slot:heading class="font-bold"&gt; <br>
                    &emsp;&emsp;&emsp;&emsp;Heading <br>
                &emsp;&emsp;&lt;/x-slot&gt; <br>
                <br>
                &emsp;&emsp;Content <br>
                <br>
                &emsp;&emsp;&lt;x-slot:footer class="text-sm"&gt; <br>
                    &emsp;&emsp;&emsp;&emsp;Footer <br>
                &emsp;&emsp;&lt;/x-slot&gt; <br>
            &lt;/x-card&gt; <br>
        </code></p>

        <!-- Fauzan -->
        <h3>#Inline Component Views</h3>
        <p>Akan terasa rumit untuk mengelola kelas <em>component</em> dan template tampilan <em>component</em> yang sangat kecil.
            Oleh karena itu, kita dapat mengembalikan <em>markup</em> <em>component</em> langsung dari <em>method</em> <code>render</code></p>
            <p><code>/**</code></p> 
            <p><code>* Get the view / contents that represent the component.</code></p>    
            <p><code>*</code></p>
            <p><code>* @return \Illuminate\View\View|\Closure|string</code></p>    
            <p><code>*/</code></p>    
            <p><code>public function render()</code></p>    
            <p><code>{</code></p>    
            <p><code>return <<<'blade'</code></p>        
            <p><code>&lt;div class="alert alert-danger">&lt;/div></code></p>            
            <p><code>{{ $slot }}</code></p>                
            <p><code></div></code></p>            
            <p><code>blade;</code></p>        
            <p><code>}</code></p>
            <br>     

        <h4>Generating Inline View Components</h4>
        <p>Untuk membuat komponen yang merender tampilan sebaris, 
            kita dapat menggunakan perintah <code>make:component</code> pada terminal</p>
            <p><code>php artisan make:component Alert --inline</code></p>
            <br>
            
        <h3>#Dynamic Components</h3>
        <p>Terkadang kita mungkin perlu merender <em>component</em> tetapi tidak tahu <em>component</em> mana yang harus dirender hingga <em>runtime</em>.
            Maka dari itu kita dapat menggunakan <code>dynamic-component</code> bawaan Laravel untuk merender berdasarkan nilai atau variabel <em>runtime</em>.</p>
            <p><code>&lt;x-dynamic-component :component="$componentName" class="mt-4" /&gt;</code></p>
            <br>

        <h3>#Manually Registering Components</h3>
            <p>Saat menulis <em>component</em> untuk aplikasi kita sendiri, 
                <em>component</em> secara otomatis ditemukan dalam <em>directory</em> <code>app/View/Components</code> dan <em>directory</em> <code>resources/views/components</code>.</p>
            <p>Namun, jika kita membuat <em>package</em> yang menggunakan <em>Blade components</em>. 
                Kita perlu mendaftarkan <em>component class</em> atau tag HTML-nya secara manual sehingga Laravel tahu di mana menemukan <em>component</em> tersebut.
                Biasanya kita harus mendaftarkan <em>component</em> dalam <code>boot</code> <em>method</em> dari <em>package's service provider</em> kita.</p>
            <p><code>use Illuminate\Support\Facades\Blade;</code></p> 
            <p><code>use VendorPackage\View\Components\AlertComponent;</code></p>     
            <p><code>/**</code></p>     
            <p><code>* Bootstrap your package's services.</code></p>     
            <p><code>*</code></p>     
            <p><code>* @return void</code></p>     
            <p><code>*/</code></p>     
            <p><code>public function boot()</code></p>     
            <p><code>{</code></p>     
            <p><code>Blade::component('package-alert', AlertComponent::class);</code></p>       
            <p><code>}</code></p>

            <p>Setelah <em>component</em> terdaftar, <em>component</em> tersebut dapat dirender menggunakan tag-nya.</p>
            <p><code>&lt;x-package-alert/></code></p>
            <br>

        <h5>Autoloading Package Components</h5>
            <p>Kita dapat menggunakan <code>componentNamespace</code> <em>method</em> untuk memuat <em>component</em> kelas secara otomatis berdasarkan konvensi.
            Misalnya <em>package</em> <code>Nightsade</code> mungkin memiliki <em>component</em> <code>calender</code> dan <code>colorPicker</code> yang berada pada <code>Package\Views\Components</code> <em>namespace</em>.</p>
            <p><code>use Illuminate\Support\Facades\Blade;</code></p>
            <p><code>/**</code></p>
            <p><code>* Bootstrap your package's services.</code></p>
            <p><code>*</code></p>
            <p><code>* @return void</code></p>
            <p><code>*/</code></p>
            <p><code>public function boot()</code></p>
            <p><code>{</code></p>
            <p><code>Blade::componentNamespace('Nightshade\\Views\\Components', 'nightshade');</code></p>
            <p><code>}</code></p>

            <p>Ini akan memungkinkan penggunaan komponen paket oleh namespace vendor mereka menggunakan <code>package-name::</code> <em>syntax</em></p>
            <p><code>&lt;x-nightshade::calendar /></code></p> 
            <p><code>&lt;x-nightshade::color-picker /></code></p>
            <p>Blade akan secara otomatis mendeteksi kelas yang ditautkan ke <em>component</em> dengan <em>pascal-casing</em> dari <em>component name</em>. Subdirektori juga didukung menggunakan <em>"dot" notation</em>.</p>
            <br>
            <br>

        <h2>#Anonymous Components</h2>
            <p>Mirip dengan <em>component</em> inline, <em>component</em> anonim menyediakan mekanisme untuk mengelola <em>component</em> melalui satu file. Namun, <em>component</em> anonim menggunakan file tampilan tunggal dan tidak memiliki kelas terkait.
                <em>component</em> anonim hanya perlu menempatkan <em>Blade template</em> di dalam <em>directory</em> <code>resources/views/components</code>. Misalnya, dengan asumsi kita telah mendefinisikan sebuah <em>component</em> di <code>resources/views/components/inputs/button.blade.php</code>
                kita dapat merendernya dengan</p> 
            <p><code>&lt;x-alert/></code></p>
            <p>Gunakan "." jika <em>component</em> bereda dalam <em>directory component</em>. Misalnya <em>component</em> didefinisikan di <code>resources/views/components/inputs/button.blade.php</code>
                kita dapat merendernya dengan</p>
            <p><code>&lt;x-inputs.button/></code></p>
            <br>

        <h3>#Anonymous Index Components</h3>
            <p>Ketika <em>component</em> terdiri dari bari <em>Blade template</em>, kita ingin mengelompokkan <em>component</em> yang ada dalam satu <em>directory</em>.
                Misal <em>component</em> "accordion" dengan struktur direktori.</p>
            <p><code>/resources/views/components/accordion.blade.php</code></p> 
            <p><code>/resources/views/components/accordion/item.blade.php</code></p>

            <p>Struktur <em>directory</em> ini memungkinkan kita untuk merender <em>component</em> accordion dan itemnya seperti</p>
            <p><code>&lt;x-accordion></code></p>
            <p><code>&lt;x-accordion.item></code></p>        
            <p><code>...</code></p>            
            <p><code>&lt;/x-accordion.item></code></p>        
            <p><code>&lt;/x-accordion></code></p>

            <p>Namun untuk merender accordion melalui <code>x-accordion</code>, kita harus menempatkan template <em>component</em> akordeon "indeks" di <em>directory</em> <code>resources/views/components</code>
            dari pada menumpuk di dalam <em>directory</em> <code>accordion</code> dengan template terkait accordion lainnya.</p>
            <p>Blade memungkinkan kita menempatkan file <code>index.blade.php</code> dalam <em>directory template component</em>. Ketika <code>index.blade.php</code> ada untuk <em>component</em>itu akan dirender sebagai simpul "root" dari komponen. 
                Jadi, kita dapat terus menggunakan sintaks Blade yang sama seperti yang diberikan. Namun, kita akan menyesuaikan struktur direktori kami seperti</p>
            <p><code>/resources/views/components/accordion/index.blade.php</code></p>
            <p><code>/resources/views/components/accordion/item.blade.php</code></p>
            <br>

        <h3>#Data Properties/Attributes</h3>
            <p>Karena <em>component</em> anonim tidak memiliki kelas terkait, bagaimana dapat membedakan data mana yang harus diteruskan ke <em>component</em> sebagai variabel dan <em>arrtibute</em> mana yang harus ditempatkan di <em>component arrtibute bag</em>.</p>
            <p>Kita dapat menentukan <em>arrtibutes</em> mana yang dianggap variabel data menggunakan <code>@props</code> dibagian atas <em>Blade templat</em>. Jika ingin memberikan nilai default pada variabel data, kita dapat menentukan nama variabel sebagai kunci array dan nilai default sebagai nilai array</p>
            <p><code>&lt;!-- /resources/views/components/alert.blade.php --></code></p>
            <p><code>@props(['type' => 'info', 'message'])</code></p>
            <p><code>&lt;div {{ $attributes->merge(['class' => 'alert alert-'.$type]) }}></code></p>
            <p><code>{{ $message }}</code></p>
            <p><code>&lt;/div></code></p>

            <p>Mengingat definisi komponen di atas, kita dapat membuat <em>component</em> seperti</p>
            <p><code>&lt;x-alert type="error" :message="$message" class="mb-4"/></code></p>
            <br>

        <h3>#Accessing Parent Data</h3>
            <p>Saat kita ingin mengakses data dari komponen <em>parent</em> di dalam komponen turunan, kita dapat menggunakan <code>@aware</code>. Misal <em>component</em> menu kompleks yang terdiri dari &lt;x-menu> <em>parent</em> dan &lt;x-menu.item> <em>child</em>.</p>
            <p><code>&lt;x-menu color="purple">&lt;/x-menu></code></p>
            <p><code>&lt;x-menu.item>...&lt;/x-menu.item></code></p>
            <p><code>&lt;x-menu.item>...&lt;/x-menu.item></code></p>
            <p><code>&lt;/x-menu></code></p>

            <p>Komponen &lt;x-menu> memiliki implementasi</p>
            <p><code>&lt;!-- /resources/views/components/menu/index.blade.php --></code></p>
            <p><code>@props(['color' => 'gray'])</code></p>
            <p><code>&lt;ul {{ $attributes->merge(['class' => 'bg-'.$color.'-200']) }}></code></p>
            <p><code>{{ $slot }}</code></p>
            <p><code>&lt;/ul></code></p>

            <p>Karena <code>color</code> prop hanya diteruskan ke <em>parent</em> (&lt;x-menu>), maka tidak akan ada di &lt;x-menu.item> Namun, jika kita menggunakan direktif <code>@aware</code>, kita juga dapat membuatnya ada di &lt;x-menu.item></x-menu.item></p>
            <p><code>&lt;!-- /resources/views/components/menu/item.blade.php --></code></p>
            <p><code>@aware(['color' => 'gray'])</code></p>
            <p><code>&lt;li {{ $attributes->merge(['class' => 'text-'.$color.'-800']) }}></code></p>
            <p><code>{{ $slot }}</code></p>
            <p><code>&lt;/li></code></p>

            <p><code>@aware</code> tidak dapat mengakses data induk yang tidak secara eksplisit diteruskan ke <em>component</em> induk melalui atribut HTML. Nilai <code>@props</code> default yang tidak secara eksplisit diteruskan ke <em>component</em> induk tidak dapat diakses oleh <code>@aware</code>.</p>

        <!-- David -->
        <h3>Anonymous Components Namespaces</h3>

        <p>Komponen anonim biasanya ditentukan dengan menempatkan template Blade di dalam direktori <em>resource/views/components</em>. Namun, sesuai kebutuhan yang mungkin ingin mendaftarkan jalur komponen anonim lainnya dengan Laravel selain jalur default.</p>
        <p>Untuk memberi tahu Laravel tentang lokasi komponen anonim ini, Anda dapat menggunakan metode <em>anonymousComponentNamespace</em> yang disediakan oleh fasad Blade. Metode <em>anonymousComponentNamespace</em> menerima "jalur" ke lokasi komponen anonim sebagai argumen pertama dan <em>"namespace"</em> yang komponennya harus ditempatkan sebagai argumen kedua. Seperti pada contoh di bawah, "namespace" akan diawali dengan nama komponen saat komponen dirender.</p>
        <figure>
            <div class="mockup-code">
              <pre data-prefix="$" class="text-success"><code>/**</code></pre>
              <pre data-prefix=">" class="text-success"><code>* Bootstrap any application services.</code></pre>
              <pre data-prefix=">" class="text-success"><code>*</code></pre>
              <pre data-prefix=">" class="text-success"><code>* @return void</code></pre>
              <pre data-prefix=">" class="text-success"><code>*</code></pre>
              <pre data-prefix=">" class="text-success"><code>public function boot()</code></pre>
              <pre data-prefix=">" class="text-success"><code>{<code></pre>
              <pre data-prefix=">" class="text-success"><code>Blade::anonymousComponentNamespace('flights.bookings.components', 'flights'); }</code></pre>
            </div>
          </figure>
    
          <h1>BUILDING LAYOUTS</h1>
          <h3>Layouts Using Components</h3>
          <p>Sebagian besar aplikasi web mempertahankan tata letak umum yang sama di berbagai halaman. Akan sangat merepotkan dan sulit untuk memelihara aplikasi jika harus mengulang seluruh tata letak HTML di setiap tampilan yang di buat. Untungnya, lebih mudah untuk mendefinisikan tata letak ini sebagai satu komponen Blade dan kemudian menggunakannya di seluruh tampilan.</p>

          <figure>
            <div class="mockup-code">
              <pre data-prefix="$" class="text-success"><code>&lt;html&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code>&lt;head&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code>&lt;title&gt;{{ $title ?? 'Todo Manager' }}&lt;/title&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code>&lt;/head&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code>&lt;body&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code>&lt;h1&gt;Todos&lt;/h1&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code>&lt;/hr&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code>{{ $slot }}<code></pre>
              <pre data-prefix=">" class="text-success"><code>&lt;/body&gt;</code></pre>
              <pre data-prefix="$" class="text-success"><code>&lt;/html&gt;</code></pre>
            </div>
          </figure>

          <p>Setelah komponen tata letak ditentukan, dapat membuat tampilan Blade yang menggunakan komponen tersebut. Ingat, konten yang disuntikkan ke dalam komponen akan diberikan ke variabel $slot default di dalam komponen layout. Seperti yang mungkin telah diperhatikan, tata letak juga menghormati slot $title jika disediakan; jika tidak, judul default akan ditampilkan. Ini dapat menyuntikkan judul khusus dari tampilan daftar tugas menggunakan sintaks slot standar yang dibahas dalam dokumentasi komponen:</p>

          <figure>
            <div class="mockup-code">
              <pre data-prefix="$" class="text-success"><code>&lt;x-layout&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code>&lt;x-slot;title&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code>Custom Title</code></pre>
              <pre data-prefix=">" class="text-success"><code>&lt;/x-slot&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code>&lt;body&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code>@foreach ($tasks as $task)</code></pre>
              <pre data-prefix=">" class="text-success"><code>{{ $task }}</code></pre>
              <pre data-prefix=">" class="text-success"><code>@endforeach<code></pre>
              <pre data-prefix=">" class="text-success"><code>&lt;/x-layout&gt;</code></pre>
            </div>
          </figure>

          <p>Sekarang setelah menentukan tampilan tata letak dan daftar tugas, sekarang hanya perlu mengembalikan tampilan tugas dari rute:</p>

          <figure>
            <div class="mockup-code">
              <pre data-prefix="$" class="text-success"><code>use App\Models\Task;</code></pre>
              <pre data-prefix=">" class="text-success"><code>      </code></pre>
              <pre data-prefix=">" class="text-success"><code>Route::get('/tasks', function () {</code></pre>
              <pre data-prefix=">" class="text-success"><code>    return view('tasks', ['tasks' => Task::all()]);</code></pre>
              <pre data-prefix=">" class="text-success"><code>});</code></pre>
            </div>
          </figure>

          <h3>Layouts Using Templates Inheritance</h3>
          <p>Tata letak juga dapat dibuat melalui <em>"Templates Inheritance"</em>. Ini adalah cara utama membangun aplikasi sebelum pengenalan komponen.

             Untuk memulai, mari klihat contoh sederhana. Pertama, kita akan memeriksa tata letak halaman. Karena sebagian besar aplikasi web mempertahankan tata letak umum yang sama di berbagai halaman, lebih mudah untuk mendefinisikan tata letak ini sebagai tampilan <em>Single Blade</em>:</p>

          <figure>
            <div class="mockup-code">
              <pre data-prefix="$" class="text-success"><code>&lt;html&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code>    &lt;head&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code>        &lt;title&gt;App Name - @yield('title')&lt;/title&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code>    &lt;/head&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code>    &lt;body&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code>        @section('sidebar')</code></pre>
              <pre data-prefix=">" class="text-success"><code>            This is the master sidebar.</code></pre>
              <pre data-prefix=">" class="text-success"><code>        @show<code></pre>
              <pre data-prefix=">" class="text-success"><code>        </code></pre>
              <pre data-prefix="$" class="text-success"><code>        &lt;div class="container"&gt;</code></pre>
              <pre data-prefix="$" class="text-success"><code>            @yield('content')</code></pre>
              <pre data-prefix="$" class="text-success"><code>        &lt;/div&gt;</code></pre>
              <pre data-prefix="$" class="text-success"><code>    &lt;/body&gt;</code></pre>
              <pre data-prefix="$" class="text-success"><code>&lt;/html&gt;</code></pre>
            </div>
          </figure>

          <p>File ini berisi mark-up HTML biasa. Namun, perhatikan arahan <em>@bagian</em> dan <em>@yield</em>. Direktif <em>@section</em>, seperti namanya, mendefinisikan bagian konten, sedangkan arahan <em>@yield</em> digunakan untuk menampilkan konten bagian tertentu.</p>

          <p>Saat mendefinisikan <em>child view</em>, gunakan perintah <em>@extends</em> Blade untuk menentukan tata letak mana yang harus <em> "inherit"</em>  oleh <em>child view</em>. Tampilan yang memperluas tata letak Blade dapat diinjeksi konten ke bagian layout menggunakan arahan <em>@section</em>. Ingat, seperti yang terlihat pada contoh di atas, konten bagian ini akan ditampilkan dalam layout menggunakan <em>@yield</em>:</p>

          <figure>
            <div class="mockup-code">
              <pre data-prefix="$" class="text-success"><code>@extends('layouts.app')</code></pre>
              <pre data-prefix=">" class="text-success"><code> </code></pre>
              <pre data-prefix=">" class="text-success"><code>@section('title', 'Page Title')</code></pre>
              <pre data-prefix=">" class="text-success"><code> </code></pre>
              <pre data-prefix=">" class="text-success"><code>@section('sidebar')</code></pre>
              <pre data-prefix=">" class="text-success"><code>    @parent</code></pre>
              <pre data-prefix=">" class="text-success"><code> </code></pre>
              <pre data-prefix="$" class="text-success"><code>    &lt;p&gt;This is appended to the master sidebar.&lt;p&gt;</code></pre>
              <pre data-prefix="$" class="text-success"><code>@endsection</code></pre>
              <pre data-prefix="$" class="text-success"><code> </code></pre>
              <pre data-prefix="$" class="text-success"><code>@section('content')</code></pre>
              <pre data-prefix="$" class="text-success"><code>    &lt;p&gt;This is my body content.&lt;p&gt;</code></pre>
              <pre data-prefix="$" class="text-success"><code>@endsection</code></pre>
            </div>
          </figure>

          <p>Arahan <em>@yield</em> juga menerima nilai default sebagai parameter kedua. Nilai ini akan diberikan jika bagian yang dihasilkan tidak ditentukan:</p>

          <figure>
            <div class="mockup-code">
              <pre data-prefix="$" class="text-success"><code></code>@yield('content', 'Default content')</code></pre>
            </div>
        </figure>

        <h1>FORMS</h1>
        <h3>CSRF Field</h3>
        <p>Setiap kali mendefinisikan formulir HTML di aplikasi, harus menyertakan <em>hidden CSRF token field</em> di formulir sehingga <em>CSRF protection middleware</em> dapat memvalidasi permintaan. Ini dapat menggunakan <em>@csrf Blade directive</em> untuk menghasilkan bidang token:</p>
        <figure>
            <div class="mockup-code">
              <pre data-prefix="$" class="text-success"><code>&lt;form method="POST" action="/profile"&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code    @csrf></code></pre>
              <pre data-prefix=">" class="text-success"><code> </code></pre>
              <pre data-prefix=">" class="text-success"><code>   . . .</code></pre>
              <pre data-prefix=">" class="text-success"><code>&lt;/form&gt;</code></pre>
            </div>
          </figure>

          <h3>Method Field</h3>
          <p>Karena formulir HTML tidak dapat membuat permintaan <em>PUT, PATCH, atau DELETE,</em>, perlu menambahkan <em>hidden _method</em> untuk menipu HTTP ini. Arahan <em>@method Blade</em> dapat membuat bidang ini.</p>
          <figure>
            <div class="mockup-code">
              <pre data-prefix="$" class="text-success"><code>&lt;form action="/foo/bar" method="POST"&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code>    @method('PUT') </code></pre>
              <pre data-prefix=">" class="text-success"><code> </code></pre>
              <pre data-prefix=">" class="text-success"><code>   . . .</code></pre>
              <pre data-prefix=">" class="text-success"><code>&lt;/form&gt;</code></pre>
            </div>
          </figure>
    
          <h3>Validation Errors</h3>
          <p>Arahan <em>@error</em> dapat digunakan untuk memeriksa dengan cepat apakah ada pesan kesalahan validasi untuk atribut tertentu. Dalam direktif <em>@error</em>, Anda dapat <em>echo</em> variabel <em>$message</em> untuk menampilkan pesan kesalahan:</p>
          <figure>
            <div class="mockup-code">
              <pre data-prefix="$" class="text-success"><code>&lt;label for="title"&gt;Post Title&lt;/label&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code> </code></pre>
              <pre data-prefix=">" class="text-success"><code>&lt;input id="title"</code></pre>
              <pre data-prefix=">" class="text-success"><code>    type="text"</code></pre>
              <pre data-prefix=">" class="text-success"><code>    class="@error('title') is-invalid @enderror"&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code> </code></pre>
              <pre data-prefix=">" class="text-success"><code>@error('title')</code></pre>
              <pre data-prefix=">" class="text-success"><code>    &lt;div class="alert alert-danger"&gt;{{ $message }}&lt;/div&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code>@enderror</code></pre>
            </div>
          </figure>
    
          <p>Karena <em>@error directive</em> dikompilasi ke <em>statement "if"</em>, dapat menggunakan <em>@else directive</em> untuk merender ketika tidak ada kesalahan untuk atribut. Lalu dapat meneruskan nama <em>error bag</em> tertentu sebagai parameter kedua ke <em>@error directive</em> untuk mengambil pesan kesalahan validasi pada halaman yang berisi beberapa formulir:</p>
          <figure>
            <div class="mockup-code">
              <pre data-prefix="$" class="text-success"><code>&lt;label for="email"&gt;Email Address&lt;/label&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code> </code></pre>
              <pre data-prefix=">" class="text-success"><code>&lt;input id="email"</code></pre>
              <pre data-prefix=">" class="text-success"><code>    type="email"</code></pre>
              <pre data-prefix=">" class="text-success"><code>    class="@error('email', 'login') is-invalid @enderror"&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code> </code></pre>
              <pre data-prefix=">" class="text-success"><code>@error('email', 'login')</code></pre>
              <pre data-prefix=">" class="text-success"><code>    &lt;div class="alert alert-danger"&gt;{{ $message }}&lt;/div&gt;</code></pre>
              <pre data-prefix=">" class="text-success"><code>@enderror</code></pre>
            </div>
          </figure>

    </body>
</html>
